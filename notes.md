## Prove greedy is optimal
After describing your algorithm, the 3 main steps for a greedy exchange argument proof are as follows:

Step 1: Label your algorithm's solution, and a general solution. For example, let A={a1,a2,...,ak} be the solution generated by your algorithm, and let O={o1,o2,...,om} be an arbitrary (or optimal) feasible solution.

Step 2: Compare greedy with other solution. Assume that your arbitrary/optimal solution is not the same as your greedy solution (since otherwise, you are done). Typically, you can isolate a simple example of this difference, such as one of the following:

- there is an element of O that is not in A and an element of A that is not in O,or
- there are 2 consecutive elements in O in a different order than they are in A (i.e. there is an inversion).
    
Step 3: Exchange. Swap the elements in question in O (either swap one element out and another in for the first case, or swap the order of the elements in the second case), and argue that you have a solution that is no worse than before.

Then argue that if you continue swapping, you can eliminate all differences between O and A in a polynomial number of steps without worsening the quality of the solution. Thus, the greedy solution produced is just as good as any optimal (or arbitrary) solution, and hence is optimal itself.

# Graph
## Floyd
```
let dist be a |V|*|V| array of minimum distances initialized to infinity
for each edge (u, v) do
    dist[u][v] = w(u, v)  // The weight of the edge (u, v)
for each vertex v do
    dist[v][v] = 0
for k from 1 to |V|
    for i from 1 to |V|
        for j from 1 to |V|
            if dist[i][j] > dist[i][k] + dist[k][j] 
                dist[i][j] = dist[i][k] + dist[k][j]
            end if
```
## Dijkstra
```
function Dijkstra(Graph, source):
      create vertex set Q

      for each vertex v in Graph:            
          dist[v] = INFINITY                 
          prev[v] = UNDEFINED                
          add v to Q                     
      dist[source] = 0                       
     
      while Q is not empty:
          u = vertex in Q with min dist[u]   
          remove u from Q
         
          for each neighbor v of u: // only v that are still in Q
              alt = dist[u] + length(u, v)
              if alt < dist[v]:              
                  dist[v] = alt
                  prev[v] = u

      return dist[], prev[]
```
### Proof of Dijkstra's algorithm is constructed by induction on the number of visited nodes.

Invariant hypothesis: For each node v, dist[v] is the shortest distance from source to v when traveling via visited nodes only, or infinity if no such path exists. (Note: we do not assume dist[v] is the actual shortest distance for unvisited nodes.)

The base case is when there is just one visited node, namely the initial node source, in which case the hypothesis is trivial.

Otherwise, assume the hypothesis for n-1 visited nodes. In which case, we choose an edge vu where u has the least dist[u] of any unvisited nodes and the edge vu is such that dist[u] = dist[v] + length[v,u]. dist[u] is considered to be the shortest distance from source to u because if there were a shorter path, and if w was the first unvisited node on that path then by the original hypothesis dist[w] > dist[u] which creates a contradiction. Similarly if there were a shorter path to u without using unvisited nodes, and if the last but one node on that path were w, then we would have had dist[u] = dist[w] + length[w,u], also a contradiction.

After processing u it will still be true that for each unvisited node w, dist[w] will be the shortest distance from source to w using visited nodes only, because if there were a shorter path that doesn't go by u we would have found it previously, and if there were a shorter path using u we would have updated it when processing u.

After all nodes are visited, the shortest path from source to any node v consists only of visited nodes, therefore dist[v] is the shortest distance. 
